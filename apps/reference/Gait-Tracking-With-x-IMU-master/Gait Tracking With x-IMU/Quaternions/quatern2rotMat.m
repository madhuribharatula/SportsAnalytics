function R = quatern2rotMat(q)
    [rows cols] = size(q);
    R = zeros(3,3, rows);
    R(1,1,:) = 2.*q(:,1).^2-1+2.*q(:,2).^2;
    R(1,2,:) = 2.*(q(:,2).*q(:,3)+q(:,1).*q(:,4));
    R(1,3,:) = 2.*(q(:,2).*q(:,4)-q(:,1).*q(:,3));
    R(2,1,:) = 2.*(q(:,2).*q(:,3)-q(:,1).*q(:,4));
    R(2,2,:) = 2.*q(:,1).^2-1+2.*q(:,3).^2;
    R(2,3,:) = 2.*(q(:,3).*q(:,4)+q(:,1).*q(:,2));
    R(3,1,:) = 2.*(q(:,2).*q(:,4)+q(:,1).*q(:,3));
    R(3,2,:) = 2.*(q(:,3).*q(:,4)-q(:,1).*q(:,2));
    R(3,3,:) = 2.*q(:,1).^2-1+2.*q(:,4).^2;
end

(2 * qi) ^ 2 - 1 + (2 * qj) ^ 2

def quatern2rotMat(q)
    (rows cols) = q.shape;
    R = np.zeros(3,3, rows);
    R[1,1,:] = 2 * q[:,0] **2 - 1 + 2 * q[:,1]** 2;
    R[1,2,:] = 2 * [q[:,1] * q[:,2] + q[:,0] * q[:,3];
    R[1,3,:] = 2 * [q[:,1] * q[:,3] - q[:,0] * q[:,2];
    R[2,1,:] = 2 * [q[:,1] * q[:,2] - q[:,0] * q[:,3];
    R[2,2,:] = 2 * q[:,0] ** 2 - 1 + 2 * q[:,2] ** 2;
    R[2,3,:] = 2 * q[:,2] * q[:,4] + q[:,0] * q[:,1];
    R[3,1,:] = 2 * q[:,1] * q[:,4] + q[:,0] * q[:,2];
    R[3,2,:] = 2 * q[:,2] * q[:,4] - q[:,0] * q[:,1];
    R[3,3,:] = 2 * q[:,0] ** 2 - 1 + 2 * q[:,3] ** 2;
    return R
end